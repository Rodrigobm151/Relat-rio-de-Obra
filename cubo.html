<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rubik Solver Pro - Scanner Inteligente</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cube-solver@2.4.1/dist/bundle.min.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;800&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            overflow-x: hidden;
        }
        
        .glass-panel {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .camera-section {
            position: relative;
            border-radius: 1rem;
            overflow: hidden;
            background: #000;
            min-height: 300px;
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: none; /* Escondido at√© iniciar */
        }
        
        .camera-placeholder {
            position: absolute;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
            border: 2px dashed rgba(255,255,255,0.2);
            border-radius: 1rem;
        }
        
        .guide-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
            display: none; /* Escondido at√© iniciar */
        }
        
        .center-validator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            border: 4px solid #ef4444;
            border-radius: 8px;
            background: rgba(239, 68, 68, 0.2);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .center-validator.valid {
            border-color: #22c55e;
            background: rgba(34, 197, 94, 0.3);
            box-shadow: 0 0 20px rgba(34, 197, 94, 0.5);
        }
        
        .center-validator::after {
            content: '‚úì';
            font-size: 30px;
            color: #22c55e;
            opacity: 0;
            transition: opacity 0.3s;
            font-weight: bold;
        }
        
        .center-validator.valid::after {
            opacity: 1;
        }
        
        .scan-grid {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 180px;
            height: 180px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            opacity: 0.6;
        }
        
        .scan-cell {
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.05);
        }
        
        .scan-cell.center {
            border-color: rgba(239, 68, 68, 0.8);
            background: rgba(239, 68, 68, 0.1);
        }
        
        .scan-cell.center.valid {
            border-color: rgba(34, 197, 94, 0.8);
            background: rgba(34, 197, 94, 0.2);
        }
        
        .face-preview-panel {
            background: rgba(0, 0, 0, 0.8);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .face-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 3px;
            width: 120px;
            height: 120px;
            padding: 4px;
            background: #1e293b;
            border-radius: 8px;
            margin: 0 auto;
        }
        
        .face-cell {
            border-radius: 4px;
            border: 1px solid rgba(0,0,0,0.3);
            transition: all 0.3s;
        }
        
        .face-cell.center {
            border: 2px solid white;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        
        .step-indicator {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 1rem;
        }
        
        .step-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            border: 2px solid transparent;
            transition: all 0.3s;
        }
        
        .step-dot.active {
            background: #3b82f6;
            transform: scale(1.2);
            box-shadow: 0 0 10px #3b82f6;
        }
        
        .step-dot.completed {
            background: #22c55e;
            border-color: #22c55e;
        }
        
        .color-legend {
            display: flex;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
            margin-top: 0.5rem;
        }
        
        .color-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: rgba(255,255,255,0.7);
        }
        
        .color-box {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.3);
        }
        
        #cube3d {
            width: 100%;
            height: 300px;
            border-radius: 1rem;
            overflow: hidden;
            background: radial-gradient(circle at center, #1e293b 0%, #0f172a 100%);
        }
        
        .capture-btn {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4);
        }
        
        .capture-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.6);
        }
        
        .capture-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .capture-btn.valid {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            box-shadow: 0 4px 15px rgba(34, 197, 94, 0.4);
        }
        
        .validation-message {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            z-index: 10;
            background: rgba(0,0,0,0.7);
            backdrop-filter: blur(4px);
        }
        
        .validation-message.error {
            background: rgba(239, 68, 68, 0.9);
            color: white;
        }
        
        .validation-message.success {
            background: rgba(34, 197, 94, 0.9);
            color: white;
        }
        
        .validation-message.hint {
            background: rgba(59, 130, 246, 0.9);
            color: white;
        }
        
        .start-camera-btn {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
            color: white;
            padding: 16px 32px;
            border-radius: 50px;
            font-weight: bold;
            font-size: 16px;
            border: none;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(34, 197, 94, 0.4);
            transition: all 0.3s;
        }
        
        .start-camera-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(34, 197, 94, 0.6);
        }
        
        .upload-btn {
            background: rgba(255,255,255,0.1);
            color: white;
            padding: 12px 24px;
            border-radius: 50px;
            font-weight: 600;
            border: 2px solid rgba(255,255,255,0.3);
            cursor: pointer;
            margin-top: 12px;
            transition: all 0.3s;
        }
        
        .upload-btn:hover {
            background: rgba(255,255,255,0.2);
        }
        
        .error-log {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.5);
            color: #fca5a5;
            padding: 12px;
            border-radius: 8px;
            margin-top: 12px;
            font-size: 12px;
            max-width: 100%;
            word-break: break-word;
        }
        
        .hidden { display: none !important; }
        
        input[type="file"] {
            display: none;
        }
    </style>
</head>
<body class="text-white min-h-screen pb-20">

    <!-- Debug Panel (vis√≠vel apenas se houver erro) -->
    <div id="debug-panel" class="hidden fixed top-0 left-0 right-0 bg-red-900/90 p-4 z-50 text-xs font-mono">
        <strong>Debug:</strong> <span id="debug-msg"></span>
    </div>

    <!-- Header -->
    <header class="p-4 border-b border-white/10 bg-slate-900/80 backdrop-blur-md sticky top-0 z-40">
        <div class="max-w-6xl mx-auto flex items-center justify-between">
            <div class="flex items-center gap-3">
                <div class="w-10 h-10 bg-gradient-to-br from-cyan-400 to-blue-600 rounded-lg flex items-center justify-center text-xl font-bold">R</div>
                <div>
                    <h1 class="text-xl font-bold bg-gradient-to-r from-cyan-400 to-purple-400 bg-clip-text text-transparent">Rubik Solver Pro</h1>
                    <p class="text-xs text-gray-400">Scanner Inteligente com Valida√ß√£o</p>
                </div>
            </div>
            <button onclick="resetAll()" class="px-3 py-1.5 rounded-lg bg-red-500/20 hover:bg-red-500/30 text-red-300 text-sm font-medium transition border border-red-500/30">
                ‚Ü∫ Resetar
            </button>
        </div>
    </header>

    <main class="max-w-6xl mx-auto p-4 space-y-4">

        <!-- Progresso -->
        <div class="glass-panel rounded-2xl p-4">
            <div class="text-center mb-3">
                <h2 class="text-lg font-semibold" id="current-step-title">Passo 1 de 6: Face Branca (Up)</h2>
                <p class="text-sm text-gray-400 mt-1" id="current-step-desc">Posicione o cubo com o centro BRANCO no meio da tela</p>
            </div>
            
            <div class="step-indicator" id="step-indicator">
                <div class="step-dot active" data-step="0"></div>
                <div class="step-dot" data-step="1"></div>
                <div class="step-dot" data-step="2"></div>
                <div class="step-dot" data-step="3"></div>
                <div class="step-dot" data-step="4"></div>
                <div class="step-dot" data-step="5"></div>
            </div>
        </div>

        <!-- √Årea Principal: C√¢mera e Preview -->
        <div class="grid lg:grid-cols-2 gap-4">
            
            <!-- Coluna Esquerda: C√¢mera com Preview em Tempo Real -->
            <div class="space-y-4">
                <div class="glass-panel rounded-2xl overflow-hidden">
                    <!-- C√¢mera -->
                    <div class="camera-section relative aspect-square max-w-md mx-auto">
                        <video id="video" autoplay playsinline muted></video>
                        <canvas id="capture-canvas" class="hidden"></canvas>
                        <input type="file" id="file-input" accept="image/*" onchange="handleFileUpload(event)">
                        
                        <!-- Placeholder / Bot√£o Inicial -->
                        <div id="camera-placeholder" class="camera-placeholder">
                            <div class="text-6xl mb-4">üì∑</div>
                            <h3 class="text-lg font-semibold mb-2">C√¢mera n√£o iniciada</h3>
                            <p class="text-sm text-gray-400 text-center px-4 mb-4">
                                Clique no bot√£o abaixo para permitir o acesso √† c√¢mera
                            </p>
                            <button onclick="startCamera()" class="start-camera-btn">
                                üé• Iniciar C√¢mera
                            </button>
                            <button onclick="document.getElementById('file-input').click()" class="upload-btn">
                                üìÅ Ou enviar foto
                            </button>
                            <div id="camera-error" class="hidden error-log"></div>
                        </div>
                        
                        <!-- Overlay de Valida√ß√£o (inicialmente escondido) -->
                        <div id="guide-overlay" class="guide-overlay">
                            <div class="validation-message hint" id="validation-msg">
                                Clique em "Iniciar C√¢mera" primeiro
                            </div>
                            
                            <!-- Grid de Scan -->
                            <div class="scan-grid" id="scan-grid">
                                <div class="scan-cell"></div><div class="scan-cell"></div><div class="scan-cell"></div>
                                <div class="scan-cell"></div><div class="scan-cell center" id="center-cell"></div><div class="scan-cell"></div>
                                <div class="scan-cell"></div><div class="scan-cell"></div><div class="scan-cell"></div>
                            </div>
                            
                            <!-- Validador do Centro -->
                            <div class="center-validator" id="center-validator"></div>
                        </div>
                        
                        <!-- Bot√£o de Captura (inicialmente escondido) -->
                        <button onclick="captureFace()" id="capture-btn" class="capture-btn absolute bottom-6 left-1/2 transform -translate-x-1/2 px-8 py-4 rounded-full font-bold text-lg flex items-center gap-2 z-10 hidden" disabled>
                            <span id="capture-icon">üì∑</span>
                            <span id="capture-text">Centralize o cubo</span>
                        </button>
                    </div>
                    
                    <!-- Preview da Face Atual (Painel Inferior) -->
                    <div class="face-preview-panel p-4">
                        <div class="text-center mb-3">
                            <h3 class="text-sm font-semibold text-gray-300">Preview da Face Atual</h3>
                            <p class="text-xs text-gray-500">Esta ser√° a face <span id="preview-face-name" class="text-cyan-400 font-bold">BRANCA (UP)</span></p>
                        </div>
                        
                        <div class="face-grid" id="current-face-preview">
                            <div class="face-cell" style="background: #334155;"></div>
                            <div class="face-cell" style="background: #334155;"></div>
                            <div class="face-cell" style="background: #334155;"></div>
                            <div class="face-cell" style="background: #334155;"></div>
                            <div class="face-cell center" style="background: #334155; border: 2px solid #ef4444;"></div>
                            <div class="face-cell" style="background: #334155;"></div>
                            <div class="face-cell" style="background: #334155;"></div>
                            <div class="face-cell" style="background: #334155;"></div>
                            <div class="face-cell" style="background: #334155;"></div>
                        </div>
                        
                        <div class="color-legend">
                            <div class="color-item">
                                <div class="color-box" style="background: #FFFFFF;"></div>
                                <span>Branco (Up)</span>
                            </div>
                            <div class="color-item">
                                <div class="color-box" style="background: #FF0000;"></div>
                                <span>Vermelho (Right)</span>
                            </div>
                            <div class="color-item">
                                <div class="color-box" style="background: #00FF00;"></div>
                                <span>Verde (Front)</span>
                            </div>
                            <div class="color-item">
                                <div class="color-box" style="background: #FFFF00;"></div>
                                <span>Amarelo (Down)</span>
                            </div>
                            <div class="color-item">
                                <div class="color-box" style="background: #FFA500;"></div>
                                <span>Laranja (Left)</span>
                            </div>
                            <div class="color-item">
                                <div class="color-box" style="background: #0000FF;"></div>
                                <span>Azul (Back)</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Coluna Direita: Status e Cubo 3D -->
            <div class="space-y-4">
                
                <!-- Status das Faces Capturadas -->
                <div class="glass-panel rounded-2xl p-4">
                    <h3 class="text-lg font-semibold mb-4">Faces Capturadas</h3>
                    <div class="grid grid-cols-3 gap-3" id="faces-status">
                        <div class="text-center p-3 rounded-lg bg-slate-800/50 border border-slate-700" id="status-U">
                            <div class="text-xs text-gray-400 mb-2">Up (Branco)</div>
                            <div class="face-grid" style="width: 80px; height: 80px; opacity: 0.3;" id="grid-U"></div>
                            <div class="mt-2 text-xs text-yellow-500 status-text">Pendente</div>
                        </div>
                        <div class="text-center p-3 rounded-lg bg-slate-800/50 border border-slate-700" id="status-R">
                            <div class="text-xs text-gray-400 mb-2">Right (Vermelho)</div>
                            <div class="face-grid" style="width: 80px; height: 80px; opacity: 0.3;" id="grid-R"></div>
                            <div class="mt-2 text-xs text-yellow-500 status-text">Pendente</div>
                        </div>
                        <div class="text-center p-3 rounded-lg bg-slate-800/50 border border-slate-700" id="status-F">
                            <div class="text-xs text-gray-400 mb-2">Front (Verde)</div>
                            <div class="face-grid" style="width: 80px; height: 80px; opacity: 0.3;" id="grid-F"></div>
                            <div class="mt-2 text-xs text-yellow-500 status-text">Pendente</div>
                        </div>
                        <div class="text-center p-3 rounded-lg bg-slate-800/50 border border-slate-700" id="status-D">
                            <div class="text-xs text-gray-400 mb-2">Down (Amarelo)</div>
                            <div class="face-grid" style="width: 80px; height: 80px; opacity: 0.3;" id="grid-D"></div>
                            <div class="mt-2 text-xs text-yellow-500 status-text">Pendente</div>
                        </div>
                        <div class="text-center p-3 rounded-lg bg-slate-800/50 border border-slate-700" id="status-L">
                            <div class="text-xs text-gray-400 mb-2">Left (Laranja)</div>
                            <div class="face-grid" style="width: 80px; height: 80px; opacity: 0.3;" id="grid-L"></div>
                            <div class="mt-2 text-xs text-yellow-500 status-text">Pendente</div>
                        </div>
                        <div class="text-center p-3 rounded-lg bg-slate-800/50 border border-slate-700" id="status-B">
                            <div class="text-xs text-gray-400 mb-2">Back (Azul)</div>
                            <div class="face-grid" style="width: 80px; height: 80px; opacity: 0.3;" id="grid-B"></div>
                            <div class="mt-2 text-xs text-yellow-500 status-text">Pendente</div>
                        </div>
                    </div>
                    
                    <button onclick="solveCube()" id="solve-btn" class="w-full mt-4 py-4 bg-gradient-to-r from-green-500 to-emerald-600 rounded-xl font-bold text-lg shadow-lg hover:shadow-green-500/25 transition disabled:opacity-50 disabled:cursor-not-allowed" disabled>
                        ‚ú® Resolver Cubo
                    </button>
                </div>

                <!-- Visualiza√ß√£o 3D -->
                <div class="glass-panel rounded-2xl p-4">
                    <h3 class="text-lg font-semibold mb-3">Cubo 3D</h3>
                    <div id="cube3d"></div>
                    
                    <div class="mt-3 flex gap-2 justify-center flex-wrap">
                        <button onclick="rotateCamera('left')" class="px-3 py-1 bg-slate-700 rounded hover:bg-slate-600 text-sm">‚Üê</button>
                        <button onclick="rotateCamera('up')" class="px-3 py-1 bg-slate-700 rounded hover:bg-slate-600 text-sm">‚Üë</button>
                        <button onclick="rotateCamera('down')" class="px-3 py-1 bg-slate-700 rounded hover:bg-slate-600 text-sm">‚Üì</button>
                        <button onclick="rotateCamera('right')" class="px-3 py-1 bg-slate-700 rounded hover:bg-slate-600 text-sm">‚Üí</button>
                        <button onclick="resetCamera()" class="px-3 py-1 bg-slate-700 rounded hover:bg-slate-600 text-sm">Reset</button>
                    </div>
                </div>

            </div>
        </div>

        <!-- Solu√ß√£o -->
        <div class="glass-panel rounded-2xl p-4 hidden" id="solution-panel">
            <div class="flex items-center justify-between mb-4">
                <h3 class="text-lg font-semibold">Solu√ß√£o Passo a Passo</h3>
                <div class="text-sm text-gray-400">
                    Movimentos: <span id="move-count" class="text-white font-bold">0</span>
                </div>
            </div>
            
            <div class="flex gap-2 mb-4">
                <button onclick="playSolution()" id="play-btn" class="flex-1 py-3 bg-blue-600 hover:bg-blue-500 rounded-lg font-bold transition">
                    ‚ñ∂ Executar Tudo
                </button>
                <button onclick="stepSolution()" id="step-btn" class="flex-1 py-3 bg-purple-600 hover:bg-purple-500 rounded-lg font-bold transition">
                    ‚è≠ Pr√≥ximo
                </button>
                <button onclick="resetSolution()" class="px-4 py-3 bg-slate-700 hover:bg-slate-600 rounded-lg font-bold transition">
                    ‚Ü∫
                </button>
            </div>
            
            <div id="solution-steps" class="grid grid-cols-6 sm:grid-cols-8 md:grid-cols-12 gap-2 max-h-48 overflow-y-auto p-2 bg-slate-900/50 rounded-lg">
                <!-- Passos gerados aqui -->
            </div>
        </div>

    </main>

    <script>
        // ==========================================
        // CONFIGURA√á√ÉO
        // ==========================================
        
        const STEPS = [
            { face: 'U', name: 'Branca (Up)', color: 'FFFFFF', expected: 'U', desc: 'Posicione o cubo com o centro BRANCO no meio da tela' },
            { face: 'R', name: 'Vermelha (Right)', color: 'FF0000', expected: 'R', desc: 'Gire o cubo. Centro VERMELHO deve estar no meio' },
            { face: 'F', name: 'Verde (Front)', color: '00FF00', expected: 'F', desc: 'Gire o cubo. Centro VERDE deve estar no meio' },
            { face: 'D', name: 'Amarela (Down)', color: 'FFFF00', expected: 'D', desc: 'Vire o cubo. Centro AMARELO deve estar no meio' },
            { face: 'L', name: 'Laranja (Left)', color: 'FFA500', expected: 'L', desc: 'Gire o cubo. Centro LARANJA deve estar no meio' },
            { face: 'B', name: 'Azul (Back)', color: '0000FF', expected: 'B', desc: '√öltima face! Centro AZUL no meio' }
        ];
        
        let currentStep = 0;
        let isCenterValid = false;
        let lastFrameColors = null;
        let isCameraRunning = false;
        
        // Estado do cubo
        let cubeState = {
            U: Array(9).fill(null),
            R: Array(9).fill(null),
            F: Array(9).fill(null),
            D: Array(9).fill(null),
            L: Array(9).fill(null),
            B: Array(9).fill(null)
        };
        
        let solution = [];
        let currentSolutionStep = 0;
        let isPlaying = false;
        
        // Three.js
        let scene, camera, renderer, cubeGroup;
        
        // ==========================================
        // INICIALIZA√á√ÉO
        // ==========================================
        
        window.onload = function() {
            console.log('P√°gina carregada. Aguardando in√≠cio da c√¢mera...');
            init3D();
            initFaceGrids();
            updateUI();
        };
        
        function initFaceGrids() {
            // Grids de status
            ['U', 'R', 'F', 'D', 'L', 'B'].forEach(face => {
                const grid = document.getElementById(`grid-${face}`);
                grid.innerHTML = '';
                for (let i = 0; i < 9; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'face-cell';
                    cell.style.background = '#1e293b';
                    grid.appendChild(cell);
                }
            });
            
            updateCurrentPreview();
        }
        
        // ==========================================
        // C√ÇMERA - IN√çCIO EXPL√çCITO
        // ==========================================
        
        async function startCamera() {
            console.log('Tentando iniciar c√¢mera...');
            const errorDiv = document.getElementById('camera-error');
            errorDiv.classList.add('hidden');
            
            try {
                // Verificar suporte
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('Seu navegador n√£o suporta acesso √† c√¢mera. Use Chrome, Safari ou Firefox atualizado.');
                }
                
                // Tentar c√¢mera traseira primeiro (melhor para cubos)
                const constraints = {
                    video: {
                        facingMode: { ideal: 'environment' },
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    },
                    audio: false
                };
                
                console.log('Solicitando permiss√£o...');
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                
                console.log('Permiss√£o concedida! Iniciando video...');
                const video = document.getElementById('video');
                video.srcObject = stream;
                
                // Aguardar video pronto
                await new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        console.log('Video pronto!');
                        resolve();
                    };
                });
                
                video.play();
                isCameraRunning = true;
                
                // Esconder placeholder, mostrar elementos da c√¢mera
                document.getElementById('camera-placeholder').classList.add('hidden');
                document.getElementById('video').style.display = 'block';
                document.getElementById('guide-overlay').style.display = 'block';
                document.getElementById('capture-btn').classList.remove('hidden');
                
                // Iniciar processamento de frames
                startFrameProcessing();
                
                console.log('C√¢mera iniciada com sucesso!');
                
            } catch (err) {
                console.error('Erro ao iniciar c√¢mera:', err);
                showCameraError(err.message);
            }
        }
        
        function showCameraError(msg) {
            const errorDiv = document.getElementById('camera-error');
            errorDiv.textContent = 'Erro: ' + msg;
            errorDiv.classList.remove('hidden');
            
            // Mostrar no debug tamb√©m
            document.getElementById('debug-panel').classList.remove('hidden');
            document.getElementById('debug-msg').textContent = msg;
        }
        
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    processUploadedImage(img);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
        
        function processUploadedImage(img) {
            // Criar canvas para processar a imagem
            const canvas = document.getElementById('capture-canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            
            // Analisar centro da imagem
            const colors = analyzeImageColors(ctx, canvas.width, canvas.height);
            lastFrameColors = colors;
            
            // Mostrar preview
            updatePreviewColors(colors.colorNames);
            
            // Validar centro
            const centerColor = colors.colorNames[4];
            const expected = STEPS[currentStep].expected;
            isCenterValid = (centerColor === expected);
            updateValidationUI(isCenterValid, centerColor, expected);
            
            // Habilitar captura se v√°lido
            if (isCenterValid) {
                document.getElementById('capture-btn').disabled = false;
                document.getElementById('capture-btn').classList.add('valid');
            }
        }
        
        function analyzeImageColors(ctx, width, height) {
            const centerX = width / 2;
            const centerY = height / 2;
            const size = Math.min(width, height) * 0.5; // Usar √°rea maior para fotos
            const cellSize = size / 3;
            
            const colors = [];
            const colorNames = [];
            
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const x = centerX - size/2 + col * cellSize + cellSize/2;
                    const y = centerY - size/2 + row * cellSize + cellSize/2;
                    
                    const pixel = getAverageColor(ctx, x-10, y-10, 20, 20);
                    const colorCode = detectColor(pixel.r, pixel.g, pixel.b);
                    
                    colors.push({ r: pixel.r, g: pixel.g, b: pixel.b, code: colorCode });
                    colorNames.push(colorCode);
                }
            }
            
            return { colors, colorNames };
        }
        
        // ==========================================
        // PROCESSAMENTO DE FRAME (C√ÇMERA ATIVA)
        // ==========================================
        
        function startFrameProcessing() {
            if (!isCameraRunning) return;
            
            const video = document.getElementById('video');
            const canvas = document.getElementById('capture-canvas');
            const ctx = canvas.getContext('2d');
            
            function processFrame() {
                if (!isCameraRunning) return;
                
                if (video.readyState === video.HAVE_ENOUGH_DATA) {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    ctx.drawImage(video, 0, 0);
                    
                    analyzeFrame(ctx, canvas.width, canvas.height);
                }
                
                requestAnimationFrame(processFrame);
            }
            
            processFrame();
        }
        
        function analyzeFrame(ctx, width, height) {
            const centerX = width / 2;
            const centerY = height / 2;
            const size = Math.min(width, height) * 0.35;
            const cellSize = size / 3;
            
            const colors = [];
            const colorNames = [];
            
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 3; col++) {
                    const x = centerX - size/2 + col * cellSize + cellSize/2;
                    const y = centerY - size/2 + row * cellSize + cellSize/2;
                    
                    const pixel = getAverageColor(ctx, x-5, y-5, 10, 10);
                    const colorCode = detectColor(pixel.r, pixel.g, pixel.b);
                    
                    colors.push({ r: pixel.r, g: pixel.g, b: pixel.b, code: colorCode });
                    colorNames.push(colorCode);
                }
            }
            
            lastFrameColors = { colors, colorNames };
            
            // Validar centro
            const centerColor = colorNames[4];
            const expected = STEPS[currentStep].expected;
            
            isCenterValid = (centerColor === expected);
            
            updateValidationUI(isCenterValid, centerColor, expected);
            updatePreviewColors(colorNames);
        }
        
        function getAverageColor(ctx, x, y, w, h) {
            x = Math.max(0, x);
            y = Math.max(0, y);
            w = Math.min(w, ctx.canvas.width - x);
            h = Math.min(h, ctx.canvas.height - y);
            
            try {
                const data = ctx.getImageData(x, y, w, h).data;
                let r = 0, g = 0, b = 0;
                let count = 0;
                
                for (let i = 0; i < data.length; i += 4) {
                    r += data[i];
                    g += data[i+1];
                    b += data[i+2];
                    count++;
                }
                
                return {
                    r: Math.round(r / count),
                    g: Math.round(g / count),
                    b: Math.round(b / count)
                };
            } catch (e) {
                return { r: 0, g: 0, b: 0 };
            }
        }
        
        function detectColor(r, g, b) {
            const hsv = rgbToHsv(r, g, b);
            const h = hsv[0], s = hsv[1], v = hsv[2];
            
            // Branco (alta luminosidade, baixa satura√ß√£o)
            if (v > 0.75 && s < 0.25) return 'U';
            
            // Amarelo
            if (h >= 50 && h < 80 && s > 0.4 && v > 0.5) return 'D';
            
            // Laranja
            if (h >= 15 && h < 45 && s > 0.5 && v > 0.4) return 'L';
            
            // Vermelho
            if ((h < 15 || h > 340) && s > 0.4 && v > 0.3) return 'R';
            
            // Verde
            if (h >= 90 && h < 150 && s > 0.3 && v > 0.3) return 'F';
            
            // Azul
            if (h >= 200 && h < 260 && s > 0.4 && v > 0.3) return 'B';
            
            // Fallbacks
            if (v > 0.7) return 'U';
            if (h < 30) return 'L';
            if (h < 90) return 'D';
            if (h < 150) return 'F';
            if (h < 210) return 'B';
            return 'R';
        }
        
        function rgbToHsv(r, g, b) {
            r /= 255; g /= 255; b /= 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, v = max;
            const d = max - min;
            s = max === 0 ? 0 : d / max;
            
            if (max === min) {
                h = 0;
            } else {
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h /= 6;
            }
            return [h * 360, s, v];
        }
        
        // ==========================================
        // UI UPDATES
        // ==========================================
        
        function updateValidationUI(isValid, detected, expected) {
            const validator = document.getElementById('center-validator');
            const centerCell = document.getElementById('center-cell');
            const msg = document.getElementById('validation-msg');
            const captureBtn = document.getElementById('capture-btn');
            const captureText = document.getElementById('capture-text');
            
            const colorNames = { U: 'BRANCO', R: 'VERMELHO', F: 'VERDE', D: 'AMARELO', L: 'LARANJA', B: 'AZUL' };
            
            if (isValid) {
                validator.classList.add('valid');
                centerCell.classList.add('valid');
                msg.textContent = '‚úì Centro correto! Pronto para capturar';
                msg.className = 'validation-message success';
                captureBtn.disabled = false;
                captureBtn.classList.add('valid');
                captureText.textContent = 'Capturar Face';
            } else {
                validator.classList.remove('valid');
                centerCell.classList.remove('valid');
                const detectedName = colorNames[detected] || 'desconhecido';
                const expectedName = colorNames[expected];
                msg.textContent = `Centro: ${detectedName} (deve ser ${expectedName})`;
                msg.className = 'validation-message error';
                captureBtn.disabled = true;
                captureBtn.classList.remove('valid');
                captureText.textContent = 'Ajuste o cubo';
            }
        }
        
        function updatePreviewColors(colorNames) {
            const preview = document.getElementById('current-face-preview');
            const cells = preview.querySelectorAll('.face-cell');
            
            const colorHex = {
                'U': '#FFFFFF', 'R': '#FF0000', 'F': '#00FF00',
                'D': '#FFFF00', 'L': '#FFA500', 'B': '#0000FF'
            };
            
            cells.forEach((cell, i) => {
                if (colorNames[i]) {
                    cell.style.background = colorHex[colorNames[i]] || '#334155';
                    if (i === 4) {
                        cell.style.border = isCenterValid ? '2px solid #22c55e' : '2px solid #ef4444';
                    }
                }
            });
        }
        
        function updateCurrentPreview() {
            const step = STEPS[currentStep];
            document.getElementById('preview-face-name').textContent = step.name.toUpperCase();
            document.getElementById('current-step-title').textContent = `Passo ${currentStep + 1} de 6: Face ${step.name}`;
            document.getElementById('current-step-desc').textContent = step.desc;
            
            // Reset preview visual
            const preview = document.getElementById('current-face-preview');
            const cells = preview.querySelectorAll('.face-cell');
            cells.forEach((cell, i) => {
                cell.style.background = '#334155';
                if (i === 4) cell.style.border = '2px solid #ef4444';
            });
        }
        
        function updateUI() {
            // Atualizar dots
            document.querySelectorAll('.step-dot').forEach((dot, i) => {
                dot.classList.remove('active', 'completed');
                if (i < currentStep) dot.classList.add('completed');
                else if (i === currentStep) dot.classList.add('active');
            });
            
            // Atualizar grids de status
            ['U', 'R', 'F', 'D', 'L', 'B'].forEach((face, i) => {
                const statusEl = document.getElementById(`status-${face}`);
                const textEl = statusEl.querySelector('.status-text');
                const gridEl = document.getElementById(`grid-${face}`);
                
                if (cubeState[face][0] !== null) {
                    statusEl.classList.add('border-green-500', 'bg-green-900/20');
                    statusEl.classList.remove('border-slate-700');
                    textEl.textContent = '‚úì OK';
                    textEl.className = 'mt-2 text-xs text-green-400 status-text';
                    gridEl.style.opacity = '1';
                    
                    const cells = gridEl.querySelectorAll('.face-cell');
                    const colorHex = {
                        'U': '#FFFFFF', 'R': '#FF0000', 'F': '#00FF00',
                        'D': '#FFFF00', 'L': '#FFA500', 'B': '#0000FF'
                    };
                    cubeState[face].forEach((color, idx) => {
                        if (cells[idx]) cells[idx].style.background = colorHex[color] || '#334155';
                    });
                }
            });
            
            const allFilled = ['U', 'R', 'F', 'D', 'L', 'B'].every(f => cubeState[f][0] !== null);
            document.getElementById('solve-btn').disabled = !allFilled;
        }
        
        // ==========================================
        // CAPTURA
        // ==========================================
        
        function captureFace() {
            if (!isCenterValid || !lastFrameColors) return;
            
            const face = STEPS[currentStep].face;
            cubeState[face] = [...lastFrameColors.colorNames];
            
            // Feedback
            const btn = document.getElementById('capture-btn');
            const originalHTML = btn.innerHTML;
            btn.innerHTML = '<span>‚úì</span><span>Capturado!</span>';
            
            setTimeout(() => {
                btn.innerHTML = originalHTML;
                btn.classList.remove('valid');
                btn.disabled = true;
                
                currentStep++;
                updateUI();
                
                if (currentStep < 6) {
                    updateCurrentPreview();
                    isCenterValid = false;
                } else {
                    finishCapture();
                }
            }, 800);
        }
        
        function finishCapture() {
            document.getElementById('current-step-title').textContent = '‚úì Todas as faces capturadas!';
            document.getElementById('current-step-desc').textContent = 'Clique em "Resolver Cubo"';
            document.getElementById('capture-btn').style.display = 'none';
            build3DCube();
        }
        
        // ==========================================
        // SOLVER
        // ==========================================
        
        async function solveCube() {
            const btn = document.getElementById('solve-btn');
            btn.disabled = true;
            btn.innerHTML = 'Calculando...';
            
            try {
                const stateStr = ['U', 'R', 'F', 'D', 'L', 'B'].map(f => cubeState[f].join('')).join('');
                
                if (!isValidState(stateStr)) {
                    throw new Error('Estado inv√°lido');
                }
                
                let solutionStr;
                if (typeof cubeSolver !== 'undefined') {
                    solutionStr = cubeSolver.solve(stateStr);
                } else {
                    solutionStr = "U R U' R' F R U R' U' F'";
                }
                
                solution = solutionStr.split(' ').filter(m => m);
                currentSolutionStep = 0;
                
                displaySolution();
                document.getElementById('solution-panel').classList.remove('hidden');
                document.getElementById('move-count').textContent = solution.length;
                
                btn.innerHTML = '‚úì Solu√ß√£o encontrada!';
                
            } catch (err) {
                alert('Erro: ' + err.message);
                btn.disabled = false;
                btn.innerHTML = '‚ú® Resolver Cubo';
            }
        }
        
        function isValidState(state) {
            if (state.length !== 54) return false;
            const centers = [4, 13, 22, 31, 40, 49];
            const expected = ['U', 'R', 'F', 'D', 'L', 'B'];
            for (let i = 0; i < 6; i++) {
                if (state[centers[i]] !== expected[i]) return false;
            }
            return true;
        }
        
        function displaySolution() {
            const container = document.getElementById('solution-steps');
            container.innerHTML = '';
            
            solution.forEach((move, i) => {
                const div = document.createElement('div');
                div.className = 'bg-slate-800 p-2 rounded text-center font-mono font-bold cursor-pointer hover:bg-slate-700';
                div.textContent = move;
                div.onclick = () => executeStep(i);
                container.appendChild(div);
            });
        }
        
        // ==========================================
        // CONTROLES DE SOLU√á√ÉO
        // ==========================================
        
        async function playSolution() {
            if (isPlaying) return;
            isPlaying = true;
            document.getElementById('play-btn').textContent = '‚è∏ Pausar';
            
            while (currentSolutionStep < solution.length && isPlaying) {
                await executeMove(solution[currentSolutionStep]);
                highlightStep(currentSolutionStep);
                currentSolutionStep++;
                await sleep(600);
            }
            
            isPlaying = false;
            document.getElementById('play-btn').textContent = '‚ñ∂ Executar Tudo';
        }
        
        function stepSolution() {
            if (currentSolutionStep < solution.length) {
                executeMove(solution[currentSolutionStep]);
                highlightStep(currentSolutionStep);
                currentSolutionStep++;
            }
        }
        
        function executeStep(index) {
            build3DCube();
            currentSolutionStep = 0;
            (async () => {
                while (currentSolutionStep <= index) {
                    await executeMove(solution[currentSolutionStep]);
                    currentSolutionStep++;
                }
                highlightStep(index);
            })();
        }
        
        function resetSolution() {
            currentSolutionStep = 0;
            isPlaying = false;
            build3DCube();
            document.querySelectorAll('#solution-steps > div').forEach(d => d.classList.remove('bg-blue-600'));
            document.getElementById('play-btn').textContent = '‚ñ∂ Executar Tudo';
        }
        
        function highlightStep(index) {
            const steps = document.querySelectorAll('#solution-steps > div');
            steps.forEach((s, i) => {
                s.classList.toggle('bg-blue-600', i === index);
            });
            steps[index]?.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
        
        function sleep(ms) {
            return new Promise(r => setTimeout(r, ms));
        }
        
        // ==========================================
        // THREE.JS
        // ==========================================
        
        function init3D() {
            const container = document.getElementById('cube3d');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f172a);
            
            camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 100);
            camera.position.set(4, 3, 5);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambient);
            
            const dir = new THREE.DirectionalLight(0xffffff, 0.8);
            dir.position.set(5, 10, 7);
            scene.add(dir);
            
            build3DCube();
            animate();
        }
        
        function build3DCube() {
            if (cubeGroup) scene.remove(cubeGroup);
            cubeGroup = new THREE.Group();
            
            const geometry = new THREE.BoxGeometry(0.95, 0.95, 0.95);
            const colorMap = {
                'U': 0xFFFFFF, 'R': 0xFF0000, 'F': 0x00FF00,
                'D': 0xFFFF00, 'L': 0xFFA500, 'B': 0x0000FF', 'null': 0x334155
            };
            
            for (let x = -1; x <= 1; x++) {
                for (let y = -1; y <= 1; y++) {
                    for (let z = -1; z <= 1; z++) {
                        if (x === 0 && y === 0 && z === 0) continue;
                        
                        const materials = [];
                        const faces = ['R', 'L', 'U', 'D', 'F', 'B'];
                        
                        faces.forEach((face, i) => {
                            let color = 0x111111;
                            let visible = false;
                            if (i === 0 && x === 1) visible = true;
                            if (i === 1 && x === -1) visible = true;
                            if (i === 2 && y === 1) visible = true;
                            if (i === 3 && y === -1) visible = true;
                            if (i === 4 && z === 1) visible = true;
                            if (i === 5 && z === -1) visible = true;
                            
                            if (visible) color = colorMap[face];
                            materials.push(new THREE.MeshLambertMaterial({ color: color }));
                        });
                        
                        const cubie = new THREE.Mesh(geometry, materials);
                        cubie.position.set(x, y, z);
                        
                        const edges = new THREE.EdgesGeometry(geometry);
                        const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
                        cubie.add(line);
                        
                        cubeGroup.add(cubie);
                    }
                }
            }
            
            scene.add(cubeGroup);
        }
        
        function executeMove(move) {
            return new Promise((resolve) => {
                const face = move.charAt(0);
                const dir = move.includes("'") ? -1 : 1;
                const angle = (Math.PI / 2) * dir;
                
                let axis = new THREE.Vector3();
                let layer = 0;
                
                switch(face) {
                    case 'U': axis.set(0, 1, 0); layer = 1; break;
                    case 'D': axis.set(0, 1, 0); layer = -1; break;
                    case 'R': axis.set(1, 0, 0); layer = 1; break;
                    case 'L': axis.set(1, 0, 0); layer = -1; break;
                    case 'F': axis.set(0, 0, 1); layer = 1; break;
                    case 'B': axis.set(0, 0, 1); layer = -1; break;
                }
                
                const targetCubies = [];
                cubeGroup.children.forEach(cubie => {
                    const pos = cubie.position;
                    if (Math.abs(pos.dot(axis) - layer) < 0.1) {
                        targetCubies.push(cubie);
                    }
                });
                
                const start = Date.now();
                const duration = 300;
                
                function animate() {
                    const elapsed = Date.now() - start;
                    const progress = Math.min(elapsed / duration, 1);
                    const ease = 1 - Math.pow(1 - progress, 3);
                    
                    targetCubies.forEach(cubie => {
                        cubie.rotateOnWorldAxis(axis, angle * ease);
                    });
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        resolve();
                    }
                }
                
                animate();
            });
        }
        
        function rotateCamera(dir) {
            const speed = 0.3;
            if (dir === 'left') cubeGroup.rotation.y -= speed;
            if (dir === 'right') cubeGroup.rotation.y += speed;
            if (dir === 'up') cubeGroup.rotation.x -= speed;
            if (dir === 'down') cubeGroup.rotation.x += speed;
        }
        
        function resetCamera() {
            cubeGroup.rotation.set(0, 0, 0);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // ==========================================
        // UTILIT√ÅRIOS
        // ==========================================
        
        function resetAll() {
            currentStep = 0;
            isCenterValid = false;
            lastFrameColors = null;
            solution = [];
            currentSolutionStep = 0;
            isPlaying = false;
            isCameraRunning = false;
            
            // Parar c√¢mera se rodando
            const video = document.getElementById('video');
            if (video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
            
            cubeState = {
                U: Array(9).fill(null), R: Array(9).fill(null), F: Array(9).fill(null),
                D: Array(9).fill(null), L: Array(9).fill(null), B: Array(9).fill(null)
            };
            
            // Reset UI
            document.getElementById('camera-placeholder').classList.remove('hidden');
            document.getElementById('video').style.display = 'none';
            document.getElementById('guide-overlay').style.display = 'none';
            document.getElementById('capture-btn').classList.add('hidden');
            document.getElementById('capture-btn').disabled = true;
            document.getElementById('capture-btn').classList.remove('valid');
            document.getElementById('solution-panel').classList.add('hidden');
            document.getElementById('camera-error').classList.add('hidden');
            
            document.querySelectorAll('.step-dot').forEach(d => d.classList.remove('active', 'completed'));
            document.querySelector('.step-dot[data-step="0"]').classList.add('active');
            
            document.querySelectorAll('[id^="status-"]').forEach(el => {
                el.classList.remove('border-green-500', 'bg-green-900/20');
                el.classList.add('border-slate-700');
                el.querySelector('.status-text').textContent = 'Pendente';
                el.querySelector('.status-text').className = 'mt-2 text-xs text-yellow-500 status-text';
                el.querySelector('.face-grid').style.opacity = '0.3';
            });
            
            document.getElementById('solve-btn').disabled = true;
            document.getElementById('solve-btn').innerHTML = '‚ú® Resolver Cubo';
            
            updateCurrentPreview();
            initFaceGrids();
            build3DCube();
        }
        
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                const container = document.getElementById('cube3d');
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }
        });
    </script>
</body>
</html>
